# Hash function

hash function 은 키 값을 입력으로 받아 해시 테이블상의 주소를 리턴한다. 해시 함수는 당므 두가지 성질을 가지도록 만들어야 한다.
- 입력 원소가 해시 테이블 전체에 고루 저장되어야 한다
- 계산이 간단해야 한다.

<br/>

## Division Method (나누기 방법)
 $h(x) = x$ $mod$ m
 $m$: 해시 테이블의 크기 

 해시 테이블의 크기 $m$은 2의 멱수에 가깝지 않은 소수를 택하는 것이 좋다. 만약 $m=2^p$ 이라면 입력 원소의 하위 p 비트에 의해 해시값이 결정되므로 해시 값을 분산시키기에 그리 이상적이지 않다.


<br/>

## Multiplication Method (곱하기 방법)
 나누기 방법은 해시 테이블 크기보다 큰 수를 해시 테이블 크기 범위에 들어오도록 수축시킨다. 곱하기 방법은 이와 반대다. 

 먼저 입력값을 0과 1 사이의 소수로 대응시킨 다음 해시 테이블 크기 m 을 곱하여 0~m-1 사이로 팽창시킨다.

 임의의 원소 $x$에 대해 다음 과정을 거쳐 $x$의 주소를 결정한다.
 - $x$에 $A$를 곱한 다음 소수부만 취한다
 - 방금 취한 소수부에 $m$을 곱하여 그 정수부를 취한다.

곱하기 방법은 나누기 방법과 달리 해시 테이블 크기 m을 아무렇게나 잡아도 상관없다. 따라서 컴퓨터 환경에 맞게 $m=2^p$로 잡는 것이 자연스럽다. 대신 상수를 어떻게 잡느냐에 따라 해시 값 분포가 많은 영향을 받는다.
 Knuth 가 제안한 잘 동작하는 상수 값으로는 $\sqrt5- 1 \over 2$ 가 있다.


<br/>
<br/>

# Collision Resolution

## Chanining 
 같은 주소로 해싱되는 원소를 모두 하나의 리스트에 매달아서 관리한다.
- 적재율이 1을 넘어도 사용할 수 있는 장점이 있다.

<br/>

## Open Addressing
 체이닝과는 달리 추가공간을 허용하지 않는다. 충돌이 일어나더라도 어떻게든 주어진 테이블 공간에서 해결한다. 따라서 모든 원소가 자신의 해시값과 일치하는 주소에 저장됨을 보장하지 않는다.

<br />

### Linear Probing (선형 조사)
 충돌이 일어나는 경우 일어난 지점에서 선형 점프를 확인하여 비어 있는 경우 그 공간을 사용한다.(그리고 비어있는 공간을 찾을때까지 이를 반복한다.)

 이의 경우 $i$번째 해시함수는 아래와 같다.

$h_{j}(x) = (h(x) +i) \ \ mod \ m$

 선형 조사의 경우 특정 영역에 원소가 몰릴때는 치명적으로 성능이 떨어진다. 이를 1차 군집 (Primary Clustering)이라고 한다.


 <br />

 ### Quadratic Probing (이차원 조사)

$h_{j}(x) = (h(x) +c_{1}i^2 + c_{2}i) \ \ mod \ m$

 이렇게 하면 선형 조사에서처럼 특정 영역에 원소가 몰려도 그 영역을 빨리 벗어날 수 있다. 
 그러나 여러 개의 원소가 동일한 초기 해시 함수 값을 갖게 되면 모두 같은 순서로 조사를 할 수 밖에 없어 비효율적이게 된다. 이를 2차 군집 (Secondary Clustering)이라 한다.

 <br />

 ### Double Hashing (더블 해싱)
$h_{j}(x) = (h(x) +i) \ \ mod \ m$

여기서 $h(x)$ 와 $f(x)$는 서로 다른 해시 함수다. 이 방법에서는 충돌이 생겨 다음에 볼 주소를 계산할때 두 번째 해시 함수 값만큼씩 점프한다. 

 여기서 조심해야 하는 것은 두 번째 해시 함수 값 $f(x)$ 가 해시 함수의 테이블 크기 $m$ 과 서로 서로 소 여야 한다는 것이다. 두 수가 1 보다 큰 최대공약수를 가지면 x의 자리를 찾기 위해 해시테이블 전체 중 기껏해야 $1 \over d$ 밖에 보지 못하게 된다. 

 Open Addressing 방법은 적재율이 1을 넘을 수 없다. 적재율이 높아지면 효율이 떨어지므로 적당한 임계점을 설정한 후 그것을 넘으면 해시 테이블의 크기를 대략 두 배로 키우고 모든 원소를 다시 해싱하는 것이 일반적이다. 마지막으로 개방 주소 방법에서 조심해야 할 것은 원소를 *삭제* 해야 하는 경우이다. 중간에 있는 원소가 삭제되는 경우 삭제한 원소를 거쳐갈 수 없어 문제가 발생한다. 이런 경우 **DELETE** flag 를 이용하여 *soft-delete* 를 하는 방식으로 해결한다.